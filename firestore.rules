rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // Helper Functions
    // ============================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if the authenticated user matches the userId in the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Check if the authenticated user owns the user document (via authUid field)
    function isUserOwner() {
      return resource.data.authUid == request.auth.uid;
    }

    // Check if the authenticated user is the owner of an expense/payment by looking up their authUid
    // This works for both WhatsApp-created items (no authUid on item) and Dashboard-created items
    function isItemOwnerByLookup(creatorUserId) {
      let creatorAuthUid = get(/databases/$(database)/documents/users/$(creatorUserId)).data.authUid;
      return request.auth.uid == creatorAuthUid;
    }

    // Check if this is the first time linking (authUid not set yet) or already linked
    function canLinkAuthUid() {
      return !('authUid' in resource.data) || resource.data.authUid == request.auth.uid;
    }

    // Validate expense data structure and constraints for CREATE
    function isValidExpenseCreate() {
      let data = request.resource.data;

      return data.keys().hasAll(['userId', 'userName', 'authUid', 'amount', 'description', 'category', 'timestamp', 'originalInput'])
        && data.userId is string
        && data.userName is string
        && data.authUid is string
        && data.amount is number
        && data.amount > 0  // Amount must be positive
        && data.description is string
        && data.description.size() >= 1
        && data.description.size() <= 500  // Max 500 characters
        && data.category in ['food', 'transport', 'accommodation', 'entertainment', 'shopping', 'general']
        && data.originalInput is string
        && data.timestamp is timestamp
        // Optional fields validation
        && (!data.keys().hasAny(['originalAmount']) || data.originalAmount is number)
        && (!data.keys().hasAny(['originalCurrency']) || data.originalCurrency is string)
        && (!data.keys().hasAny(['splitAmong']) || data.splitAmong is list);
    }

    // Validate expense data structure and constraints for UPDATE
    // More lenient: authUid and originalInput are optional (WhatsApp-created expenses may not have them)
    function isValidExpenseUpdate() {
      let data = request.resource.data;

      return data.keys().hasAll(['userId', 'userName', 'amount', 'description', 'category', 'timestamp'])
        && data.userId is string
        && data.userName is string
        && data.amount is number
        && data.amount > 0  // Amount must be positive
        && data.description is string
        && data.description.size() >= 1
        && data.description.size() <= 500  // Max 500 characters
        && data.category in ['food', 'transport', 'accommodation', 'entertainment', 'shopping', 'general']
        && data.timestamp is timestamp
        // Optional fields validation
        && (!data.keys().hasAny(['authUid']) || data.authUid is string)
        && (!data.keys().hasAny(['originalInput']) || data.originalInput is string)
        && (!data.keys().hasAny(['originalAmount']) || data.originalAmount is number)
        && (!data.keys().hasAny(['originalCurrency']) || data.originalCurrency is string)
        && (!data.keys().hasAny(['splitAmong']) || data.splitAmong is list);
    }

    // Validate payment data structure and constraints
    function isValidPayment() {
      let data = request.resource.data;

      return data.keys().hasAll(['groupId', 'fromUserId', 'toUserId', 'amount', 'recordedBy', 'authUid', 'createdAt'])
        && data.groupId is string
        && data.fromUserId is string
        && data.toUserId is string
        && data.fromUserId != data.toUserId  // Cannot pay yourself
        && data.amount is number
        && data.amount > 0  // Amount must be positive
        && data.recordedBy is string
        && data.authUid is string
        && data.createdAt is timestamp
        // Optional fields validation
        && (!data.keys().hasAny(['note']) || data.note is string);
    }

    // Validate user data structure
    function isValidUser() {
      let data = request.resource.data;

      return data.keys().hasAll(['name', 'phone'])
        && data.name is string
        && data.name.size() >= 1
        && data.name.size() <= 100
        && data.phone is string
        && data.phone.size() >= 10
        && data.phone.size() <= 20
        // Optional fields
        && (!data.keys().hasAny(['email']) || data.email is string)
        && (!data.keys().hasAny(['authUid']) || data.authUid is string)
        && (!data.keys().hasAny(['aliases']) || data.aliases is list)
        && (!data.keys().hasAny(['paymentInfo']) || data.paymentInfo is map)
        && (!data.keys().hasAny(['phoneNumber']) || data.phoneNumber is string) // legacy field
        && (!data.keys().hasAny(['avatar']) || data.avatar is string);
    }

    // ============================================
    // Users Collection
    // ============================================
    match /users/{userId} {
      // Anyone authenticated can read user profiles (needed for @mentions and display)
      allow read: if isAuthenticated();

      // Only allow creating/updating own user document
      // In production, user creation should be handled by backend/Cloud Functions
      allow create: if isAuthenticated()
                    && isOwner(userId)
                    && isValidUser();

      // Allow updates if:
      // 1. User is authenticated
      // 2. Either first time linking authUid OR authUid matches
      // 3. Phone number cannot be changed after creation
      allow update: if isAuthenticated()
                    && canLinkAuthUid()
                    && request.resource.data.phone == resource.data.phone
                    // Once authUid is set, only that user can update
                    && (
                      !('authUid' in resource.data)
                      || resource.data.authUid == request.auth.uid
                    );

      // Users cannot delete their own profile (should be handled by admin)
      allow delete: if false;
    }

    // ============================================
    // Expenses Collection
    // ============================================
    match /expenses/{expenseId} {
      // All authenticated users can read expenses (collaborative tracking)
      allow read: if isAuthenticated();

      // Users can create expenses - authUid must match their Firebase Auth UID
      // Note: WhatsApp-created expenses bypass rules (Admin SDK), so this only applies to Dashboard
      allow create: if isAuthenticated()
                    && request.resource.data.authUid == request.auth.uid
                    && isValidExpenseCreate();

      // Any authenticated user can update expenses (collaborative editing)
      // This allows group members to fix/edit any expense in their group
      allow update: if isAuthenticated()
                    && isValidExpenseUpdate()
                    // Prevent changing the owner of an expense
                    && request.resource.data.userId == resource.data.userId;

      // Any authenticated user can delete expenses (collaborative management)
      allow delete: if isAuthenticated();
    }

    // ============================================
    // Groups Collection
    // ============================================
    match /groups/{groupId} {
      // All authenticated users can read groups (collaborative app)
      // Note: Firebase Auth UID differs from Firestore user ID, so we can't check membership directly
      allow read: if isAuthenticated();

      // Only allow group creation/updates by admin (should be backend/Cloud Functions)
      // For now, allowing authenticated users to create/update groups
      allow create: if isAuthenticated()
                    && request.resource.data.keys().hasAll(['name', 'members', 'createdBy'])
                    && request.resource.data.name is string
                    && request.resource.data.members is list
                    && request.resource.data.createdBy is string;

      allow update: if isAuthenticated()
                    && request.resource.data.keys().hasAll(['name', 'members', 'createdBy']);

      allow delete: if false; // Groups should not be deleted casually
    }

    // ============================================
    // Payments Collection
    // ============================================
    match /payments/{paymentId} {
      // Helper: Check if current user is one of the parties in the payment
      function isPaymentParty() {
        let fromUserAuthUid = get(/databases/$(database)/documents/users/$(resource.data.fromUserId)).data.authUid;
        let toUserAuthUid = get(/databases/$(database)/documents/users/$(resource.data.toUserId)).data.authUid;
        return request.auth.uid == fromUserAuthUid || request.auth.uid == toUserAuthUid;
      }

      // Helper: Check if current user is the one who recorded the payment
      function isPaymentRecorder() {
        let recorderAuthUid = get(/databases/$(database)/documents/users/$(resource.data.recordedBy)).data.authUid;
        return request.auth.uid == recorderAuthUid;
      }

      // All authenticated users can read payments (collaborative tracking)
      allow read: if isAuthenticated();

      // Users can create payments - authUid must match their Firebase Auth UID
      // Note: WhatsApp-created payments bypass rules (Admin SDK), so this only applies to Dashboard
      allow create: if isAuthenticated()
                    && request.resource.data.authUid == request.auth.uid
                    && isValidPayment();

      // Only the person who recorded the payment can update it
      // Uses lookup to support both WhatsApp and Dashboard-created payments
      allow update: if isAuthenticated()
                    && isPaymentRecorder()
                    && isValidPayment()
                    // Prevent changing critical fields
                    && request.resource.data.recordedBy == resource.data.recordedBy;

      // Either party involved in the payment can delete it
      allow delete: if isAuthenticated() && isPaymentParty();
    }

    // ============================================
    // Deny all other collections
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
